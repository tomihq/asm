n
make
run
make
make
run
n
make
run
n
run
n
n
n
n
n
n
n
make
run
n
si
n
make
git add. 
make
make
run
n
run
n
si
n
make
make
make
make
./test_asm
quit
b segmentar_casos
run
n
si
n
si
n
n
make
exit
run
n
b segmentar_casos 
run
n
make
run
n
run
n
run
n
make
run
n
make
b initializeLevelCounterArr
b initializeLevelCounterArr
make
make
make
b fillSegmentationPointerCaseLoopZero
b fillSegmentationPointerCasesLoop
b fillSegmentationPointerCases
b assignSecondLevelArrMem
b assignFirstLevelArrMem
b saveSpaceForArrPointers
b initializeLevelCounterArr
make
b .createLevelCounterArr
b createLevelCounterArr
b createLevelCounterArr
make clean
make 
b createLevelCounterArr
make
run
n
n
p $r15
p *((caso_t*) $r15)
p *((caso_t*) $r15 + 1)
p *((caso_t*) $r15 + 2)
p *((caso_t*) $r15 + 0)
p *($r15 + sizeof(caso_t))
p *($r15 + sizeof(caso_t))
p *($r15 + 1 * sizeof(caso_t))
p *($r15 + 1 * sizeof(caso_t)) -> categoria
p *((caso_t*) $r15 + 2)
p *((caso_t*) $r15 + 2) -> categoria
p *((caso_t*) $r15 + 2) -> estado
p ((caso_t*) $r15 + 1)->estado
p ((caso_t*) $r15 + 0)
p ((caso_t*) $r15)
p ((caso_t*) $r15)
n
p ((caso_t*) $r15)
p ((caso_t*) $r15 + 0)
p *((caso_t*) $r12)
p *((caso_t*) $r12) -> estado
p *((caso_t*) $r12 + 0) -> estado
p *((caso_t*) $r12 + 1) -> estado
p *((caso_t*) $r12) -> estado
p ((caso_t*) $r12) -> estado
p ((caso_t*) $r12) -> categoria
p *((caso_t*) $r12)
p ((caso_t*) $r12) -> categoria
p *((caso_t*) $r12).categoria
p ((caso_t*) $r12).categoria
p ((caso_t*) $r12).categoria
p ((caso_t*) $r12) -> usuario
p *((caso_t*) $r12) -> usuario
p ((caso_t*) $r12) -> usuario
clear
p $r12
p *((caso_t*) $r12)
p *((caso_t*) $r12 + 1) -> usuario
p (*((caso_t*) $r12 + 1) -> usuario)
p (*((caso_t*) $r12 + 1) -> usuario).nivel
p (*((caso_t*) $r12 + 1).usuario).nivel
p (((caso_t*) $r12 + 1) -> usuario).nivel
p (((caso_t*) $r12 + 1).usuario).nivel
p ((caso_t*) $r12 + 1)) -> usuario -> nivel
p ((caso_t*) $r12 + 1) -> usuario -> nivel
p ((caso_t*) $r12 + 1) -> categoria
n
n
n
p *((caso_t*) $r9)
p *((caso_t*) $r9)
n
p *((caso_t*) $r9)
p $r14
p $r10
p *((usuario_t*) $r10)
p/x $r10
p *(long *)($r9 + CASO_USUARIO_OFFSET)
p (caso_t*) $r9 -> usuario
p ((caso_t*) $r9) -> usuario
p ((caso_t*) $r9) -> usuario
p/x $r10
p ((usuario_t*) $r10)->nivel
n
p *((caso_t*) $r10)
p *((segmentacion_t*) $r10)
p *((segmentacion_t*) $r15)
p *((segmentacion_t*) $r15 +1)
p *((segmentacion_t*) $r15 + 2)
p *((segmentacion_t*) $r15)
p *((segmentacion_t*) $r15) -> casos_nivel_1
p *((segmentacion_t*) $r15) -> casos_nivel_1 + 1
p *((segmentacion_t*) $r15) -> casos_nivel_1
n
p/x $rdi
p *((caso_t*) $r10)
p *((segmentacion_t*) $r15)
make
run
n
make
run
n
p *((usuario_t*) $r10)
n
p *((usuario_t*) $r10)
p *((usuario_t*) $r14)
p *((uint32_t) $r14)
p ((uint32_t) $r14)
n
p $r10
p *((caso_t*) $r15)
p *((caso_t*) $r15)
n
p $rsi
n
p $r10
n
p $r14
p *((caso_t*) $r14)
n
make
make
run
n
n
make
make
run
n
p $r15
p *((segmentacion_t*) $r15)
p *((segmentacion_t*) $r15) -> casos_nivel_1
p *((segmentacion_t*) $r15) -> casos_nivel_1[0]
p *((segmentacion_t*) $r15) -> casos_nivel_1
p *((caso_t*) (((segmentacion_t*) $r15)->casos_nivel_1) + 1)
n
exit
q
b segmentar_casos
run
n
p *((caso_t*) $r12)
n
n
p *((caso_t*) $r12)
p/x $r9
p $r10
p $r9
p $r10
p $rsp
p $r9
n
p $r9
n
p $r9
p/x $r9
n
n
p ((caso_t*) $r12)
p *((caso_t*) $r12)
p/x $r9
p *((caso_t*) $r12+1)
p *((caso_t*) $r12+2)
p *((caso_t*) $r12+3)
p *((caso_t*) $r12+4)
p *((caso_t*) $r9)
p *((caso_t*) $r12)
p/x $r9
p/x $r9
p/x $r12
p/x $r12+1
p/x $r12+16
p/x $r12+24
p/x $r12+24n
n
p *((caso_t*) $r9)
p ((caso_t*) $r9) -> usuario
p *((caso_t*) $r9) -> usuario
p *((usuario_t) $r10)
p *((usuario_t*) $r10)
p *((caso_t*) $r9)
p *((caso_t*) $r9) -> usuario
p *((usuario_t*) $r10)
p *((caso_t*) $r9) -> usuario -> nivel
p *((caso_t*) $r9) -> usuario. nivel
p *((caso_t*) $r9) -> usuario.nivel
p ((caso_t*) $r9) -> usuario -> nivel
