# Cartas

## Offset
El puntero siempre arranca en el inicio de la estructura. El offset nos permite saber a partir de cuántos bytes empieza un campo particular.

## Tipos de datos
bool = 1 byte

## Padding
Si tengo un array de structs (packed) solo está el packed en cada struct. No en el array. Esto es *muy ineficiente*.

Repasar ejercicios con packed y unpacked (en los integradores está, la idea la entiendo pero nomas como se ve a ojo el uso de cada una)

## Matriz

carta_t* campo[ALTO_CAMPO][ANCHO_CAMPO] (reservás un espacio en linea de ALTO * ANCHO. Esto lo interpreta normalmente como si haces p[i][j] te hace el movimiento del offset)

tons es //8 bytes * ALTO * ANCHO 

## Booleanos
Devolver un bool, podemos usar para almacenar TRUE/FALSE de la siguiente manera: mov r14, FALSE / mov r14, TRUE
Ojo, FALSE ni TRUE existen. Se definen con EQU.

FALSE equ 0
TRUE equ 1

## Punteros
Recordar que si el puntero es null se puede usar 0 (apuntan a 0). 
cmp r12, 0

## Llamar a funcion en lugar de memoria
call [r12 + accion.invocar]

## Blanquear registros
Siempre que quieras usar registros para operar y meter algo más chico blanquealos.
Ej.: si en RAX querés meter un bool, antes de todo hace xor rax, rax para dejarlo en 0 y después meté el booleano.
Si metés algo más chico que el tamaño del registro capaz queda basura.

## Comparar solo una parte especifica
cmp WORD[r8 + carta.vida], 0

## Hacer cálculo y pasarlo a registro
mov r8, (campo.ALTO*campo.ANCHO)

## Preguntas
¿Por qué hizo mov DWORD[rdx], 0 en vez de mov edx 0? ¿Se quiere quedar con la parte alta o algo? 
Porque RDX tiene un puntero adentro de 32 bits. Entonces, para "pisarlo", necesito hacerlo. Porque ninguno de los dos tiene un tamaño especificado si uso mov rdx, 0.
¿Por qué hizo QWORD[RDI+R9*8], 0? ¿Qué cosa mide 8 bytes?
¿Por qué inc DWORD[RDX] en vez de inc EDX?